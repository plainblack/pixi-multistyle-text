{"version":3,"file":"pixi-multistyle-text.umd.js","sources":["../src/pixi-multistyle-text.ts"],"sourcesContent":["import * as PIXI from \"pixi.js\";\n\n\"use strict\";\n\nconst majorVersion = parseInt(PIXI.VERSION.split(\".\")[0], 10);\nif (majorVersion< 5) {\n  throw new Error(`Detected Pixi.js version ${PIXI.VERSION}. pixi-multistyle-text supports Pixi.js version 5+. (Please use v0.8.0 for Pixi 4 support.)`);\n}\n\ninterface TextStyle {\n  align?: string;\n  breakWords?: boolean;\n  dropShadow?: boolean;\n  dropShadowAlpha?: number;\n  dropShadowAngle?: number;\n  dropShadowBlur?: number;\n  dropShadowColor?: string | number;\n  dropShadowDistance?: number;\n  fill?: string | string[] | number | number[] | CanvasGradient | CanvasPattern;\n  fillGradientType?: number;\n  fillGradientStops?: number[];\n  fontFamily?: string | string[];\n  fontSize?: number | string;\n  fontStyle?: string;\n  fontVariant?: string;\n  fontWeight?: string;\n  leading?: number;\n  letterSpacing?: number;\n  lineHeight?: number;\n  lineJoin?: string;\n  miterLimit?: number;\n  padding?: number;\n  stroke?: string | number;\n  strokeThickness?: number;\n  trim?: boolean;\n  textBaseline?: string;\n  whiteSpace?: string;\n  wordWrap?: boolean;\n  wordWrapWidth?: number;\n}\n\nexport interface TextStyleExtended extends TextStyle {\n\tvalign?: \"top\" | \"middle\" | \"bottom\" | \"baseline\" | number;\n\tdebug?: boolean;\n\ttagStyle?: \"xml\" | \"bbcode\";\n}\n\nexport interface TextStyleSet {\n\t[key: string]: TextStyleExtended;\n}\n\ninterface FontProperties {\n\tascent: number;\n\tdescent: number;\n\tfontSize: number;\n}\n\ninterface TextData {\n\ttext: string;\n\tstyle: TextStyleExtended;\n\twidth: number;\n\theight: number;\n\tfontProperties: FontProperties;\n\ttag: TagData;\n}\n\ninterface TextDrawingData {\n\ttext: string;\n\tstyle: TextStyleExtended;\n\tx: number;\n\ty: number;\n\twidth: number;\n\tascent: number;\n\tdescent: number;\n\ttag: TagData;\n}\n\nexport interface MstDebugOptions {\n\tspans: {\n\t\tenabled?: boolean;\n\t\tbaseline?: string;\n\t\ttop?: string;\n\t\tbottom?: string;\n\t\tbounding?: string;\n\t\ttext?: boolean;\n\t};\n\tobjects: {\n\t\tenabled?: boolean;\n\t\tbounding?: string;\n\t\ttext?: boolean;\n\t}\n}\n\nexport interface TagData {\n\tname: string;\n\tproperties: { [key: string]: string };\n}\n\nexport interface MstInteractionEvent extends PIXI.interaction.InteractionEvent {\n\ttargetTag: TagData;\n}\n\nconst INTERACTION_EVENTS = [\n\t\"pointerover\",\n\t\"pointerenter\",\n\t\"pointerdown\",\n\t\"pointermove\",\n\t\"pointerup\",\n\t\"pointercancel\",\n\t\"pointerout\",\n\t\"pointerleave\",\n\t\"gotpointercapture\",\n\t\"lostpointercapture\",\n\t\"mouseover\",\n\t\"mouseenter\",\n\t\"mousedown\",\n\t\"mousemove\",\n\t\"mouseup\",\n\t\"mousecancel\",\n\t\"mouseout\",\n\t\"mouseleave\",\n\t\"touchover\",\n\t\"touchenter\",\n\t\"touchdown\",\n\t\"touchmove\",\n\t\"touchup\",\n\t\"touchcancel\",\n\t\"touchout\",\n\t\"touchleave\"\n];\n\nconst TAG_STYLE = {\n\tbbcode: \"bbcode\",\n\txml: \"xml\"\n};\n\nconst TAG = {\n\tbbcode: [\"[\", \"]\"],\n\txml: [\"<\", \">\"]\n};\n\ninterface TextWithPrivateMembers extends PIXI.Text {\n  dirty: boolean;\n  _texture: PIXI.Texture;\n  _style: PIXI.TextStyle;\n  _onTextureUpdate(): void;\n  _generateFillStyle(style: object, lines: string[]): string | number | CanvasGradient;\n}\n\nexport default class MultiStyleText extends PIXI.Text {\n\tprivate static DEFAULT_TAG_STYLE: TextStyleExtended = {\n\t\talign: \"left\",\n\t\tbreakWords: false,\n\t\t// debug intentionally not included\n\t\tdropShadow: false,\n\t\tdropShadowAngle: Math.PI / 6,\n\t\tdropShadowBlur: 0,\n\t\tdropShadowColor: \"#000000\",\n\t\tdropShadowDistance: 5,\n\t\tfill: \"black\",\n\t\tfillGradientType: PIXI.TEXT_GRADIENT.LINEAR_VERTICAL,\n\t\tfontFamily: \"Arial\",\n\t\tfontSize: 26,\n\t\tfontStyle: \"normal\",\n\t\tfontVariant: \"normal\",\n\t\tfontWeight: \"normal\",\n\t\tletterSpacing: 0,\n\t\tlineHeight: 0,\n\t\tlineJoin: \"miter\",\n\t\tmiterLimit: 10,\n\t\tpadding: 0,\n\t\tstroke: \"black\",\n\t\tstrokeThickness: 0,\n\t\ttextBaseline: \"alphabetic\",\n\t\tvalign: \"baseline\",\n\t\twordWrap: false,\n\t\twordWrapWidth: 100,\n\t\ttagStyle: \"xml\"\n\t};\n\n\tpublic static debugOptions: MstDebugOptions = {\n\t\tspans: {\n\t\t\tenabled: false,\n\t\t\tbaseline: \"#44BB44\",\n\t\t\ttop: \"#BB4444\",\n\t\t\tbottom: \"#4444BB\",\n\t\t\tbounding: \"rgba(255, 255, 255, 0.1)\",\n\t\t\ttext: true\n\t\t},\n\t\tobjects: {\n\t\t\tenabled: false,\n\t\t\tbounding: \"rgba(255, 255, 255, 0.05)\",\n\t\t\ttext: true\n\t\t}\n\t};\n\n\tprivate textStyles: TextStyleSet;\n\n\tprivate hitboxes: { tag: TagData, hitbox: PIXI.Rectangle }[];\n\n\tconstructor(text: string, styles: TextStyleSet) {\n\t\tsuper(text);\n\n\t\tthis.styles = styles;\n\n\t\tINTERACTION_EVENTS.forEach((event) => {\n\t\t\tthis.on(event, (e: PIXI.interaction.InteractionEvent) => this.handleInteraction(e));\n\t\t});\n\t}\n\n\tprivate handleInteraction(e: PIXI.interaction.InteractionEvent) {\n\t\tlet ev = e as MstInteractionEvent;\n\n\t\tlet localPoint = e.data.getLocalPosition(this);\n\t\tlet targetTag = this.hitboxes.reduce((prev, hitbox) => prev !== undefined ? prev : (hitbox.hitbox.contains(localPoint.x, localPoint.y) ? hitbox : undefined), undefined);\n\t\tev.targetTag = targetTag === undefined ? undefined : targetTag.tag;\n\t}\n\n\tpublic set styles(styles: TextStyleSet) {\n\t\tthis.textStyles = {};\n\n\t\tthis.textStyles[\"default\"] = this.assign({}, MultiStyleText.DEFAULT_TAG_STYLE);\n\n\t\tfor (let style in styles) {\n\t\t\tif (style === \"default\") {\n\t\t\t\tthis.assign(this.textStyles[\"default\"], styles[style]);\n\t\t\t} else {\n\t\t\t\tthis.textStyles[style] = this.assign({}, styles[style]);\n\t\t\t}\n\t\t}\n\t\tif (this.textStyles.default.tagStyle === TAG_STYLE.bbcode) {\n\t\t\t// when using bbcode parsing, register a bunch of standard bbcode tags and some cool pixi ones\n\t\t\tthis.textStyles.b = this.assign({}, {fontStyle: 'bold'});\n\t\t\tthis.textStyles.i = this.assign({}, {fontStyle: 'italic'});\n\t\t\tthis.textStyles.color = this.assign({}, {fill: ''}); // an array would result in gradients\n\t\t\tthis.textStyles.outline = this.assign({}, {stroke: '', strokeThickness: 6});\n\t\t\tthis.textStyles.font = this.assign({}, {fontFamily: ''});\n\t\t\tthis.textStyles.shadow = this.assign({}, {\n\t\t\t\tdropShadowColor: '', dropShadow: true, dropShadowBlur: 3, dropShadowDistance: 3, dropShadowAngle: 2,});\n\t\t\tthis.textStyles.size = this.assign({}, {fontSize: 'px'});\n\t\t\tthis.textStyles.spacing = this.assign({}, {letterSpacing: ''});\n\t\t\tthis.textStyles.align = this.assign({}, {align: ''});\n\t\t}\n\n\t\tthis.withPrivateMembers()._style = new PIXI.TextStyle(this.textStyles[\"default\"]);\n\t\tthis.withPrivateMembers().dirty = true;\n\t}\n\n\tpublic setTagStyle(tag: string, style: TextStyleExtended): void {\n\t\tif (tag in this.textStyles) {\n\t\t\tthis.assign(this.textStyles[tag], style);\n\t\t} else {\n\t\t\tthis.textStyles[tag] = this.assign({}, style);\n\t\t}\n\n\t\tthis.withPrivateMembers()._style = new PIXI.TextStyle(this.textStyles[\"default\"]);\n\t\tthis.withPrivateMembers().dirty = true;\n\t}\n\n\tpublic deleteTagStyle(tag: string): void {\n\t\tif (tag === \"default\") {\n\t\t\tthis.textStyles[\"default\"] = this.assign({}, MultiStyleText.DEFAULT_TAG_STYLE);\n\t\t} else {\n\t\t\tdelete this.textStyles[tag];\n\t\t}\n\n\t\tthis.withPrivateMembers()._style = new PIXI.TextStyle(this.textStyles[\"default\"]);\n\t\tthis.withPrivateMembers().dirty = true;\n\t}\n\n\tprivate getTagRegex(captureName: boolean, captureMatch: boolean): RegExp {\n\t\tlet tagAlternation = Object.keys(this.textStyles).join(\"|\");\n\t\tconst { tagStyle } = this.textStyles.default;\n\n\t\tif (captureName) {\n\t\t\ttagAlternation = `(${tagAlternation})`;\n\t\t} else {\n\t\t\ttagAlternation = `(?:${tagAlternation})`;\n\t\t}\n\n\t\tlet reStr = tagStyle === TAG_STYLE.bbcode ? `\\\\${TAG.bbcode[0]}${tagAlternation}(?:\\\\=(?:[A-Za-z0-9_\\\\-\\\\#]+|'(?:[^']+|\\\\\\\\')*'))*\\\\s*\\\\${TAG.bbcode[1]}|\\\\${TAG.bbcode[0]}\\\\/${tagAlternation}\\\\s*\\\\${TAG.bbcode[1]}`\n\t\t: `\\\\${TAG.xml[0]}${tagAlternation}(?:\\\\s+[A-Za-z0-9_\\\\-]+=(?:\"(?:[^\"]+|\\\\\\\\\")*\"|'(?:[^']+|\\\\\\\\')*'))*\\\\s*\\\\${TAG.xml[1]}|\\\\${TAG.xml[0]}\\\\/${tagAlternation}\\\\s*\\\\${TAG.xml[1]}`;\n\n\t\tif (captureMatch) {\n\t\t\treStr = `(${reStr})`;\n\t\t}\n\n\t\treturn new RegExp(reStr, \"g\");\n\t}\n\n\tprivate getPropertyRegex(): RegExp {\n\t\treturn new RegExp(`([A-Za-z0-9_\\\\-]+)=(?:\"((?:[^\"]+|\\\\\\\\\")*)\"|'((?:[^']+|\\\\\\\\')*)')`, \"g\");\n\t}\n\n\tprivate getBBcodePropertyRegex(): RegExp {\n\t\treturn new RegExp(`[A-Za-z0-9_\\\\-]+=([A-Za-z0-9_\\\\-\\\\#]+)`, \"g\");\n\t}\n\n\tprivate _getTextDataPerLine (lines: string[]) {\n\t\tlet outputTextData: TextData[][] = [];\n\t\tlet re = this.getTagRegex(true, false);\n\n\t\tlet styleStack = [this.assign({}, this.textStyles[\"default\"])];\n\t\tlet tagStack: TagData[] = [{ name: \"default\", properties: {} }];\n\n\t\t// determine the group of word for each line\n\t\tfor (let i = 0; i < lines.length; i++) {\n\t\t\tlet lineTextData: TextData[] = [];\n\n\t\t\t// find tags inside the string\n\t\t\tlet matches: RegExpExecArray[] = [];\n\t\t\tlet matchArray: RegExpExecArray;\n\n\t\t\twhile (matchArray = re.exec(lines[i])) {\n\t\t\t\tmatches.push(matchArray);\n\t\t\t}\n\t\t\t// if there is no match, we still need to add the line with the default style\n\t\t\tif (matches.length === 0) {\n\t\t\t\tlineTextData.push(this.createTextData(lines[i], styleStack[styleStack.length - 1], tagStack[tagStack.length - 1]));\n\t\t\t}\n\t\t\telse {\n\t\t\t\t// We got a match! add the text with the needed style\n\t\t\t\tlet currentSearchIdx = 0;\n\t\t\t\tfor (let j = 0; j < matches.length; j++) {\n\t\t\t\t\t// if index > 0, it means we have characters before the match,\n\t\t\t\t\t// so we need to add it with the default style\n\t\t\t\t\tif (matches[j].index > currentSearchIdx) {\n\t\t\t\t\t\tlineTextData.push(this.createTextData(\n\t\t\t\t\t\t\tlines[i].substring(currentSearchIdx, matches[j].index),\n\t\t\t\t\t\t\tstyleStack[styleStack.length - 1],\n\t\t\t\t\t\t\ttagStack[tagStack.length - 1]\n\t\t\t\t\t\t));\n\t\t\t\t\t}\n\n\t\t\t\t\tif (matches[j][0][1] === \"/\") { // reset the style if end of tag\n\t\t\t\t\t\tif (styleStack.length > 1) {\n\t\t\t\t\t\t\tstyleStack.pop();\n\t\t\t\t\t\t\ttagStack.pop();\n\t\t\t\t\t\t}\n\t\t\t\t\t} else { // set the current style\n\t\t\t\t\t\tlet properties: { [key: string]: string } = {};\n\t\t\t\t\t\tlet propertyRegex = this.getPropertyRegex();\n\t\t\t\t\t\tlet propertyMatch: RegExpMatchArray;\n\n\t\t\t\t\t\twhile (propertyMatch = propertyRegex.exec(matches[j][0])) {\n\t\t\t\t\t\t\tproperties[propertyMatch[1]] = propertyMatch[2] || propertyMatch[3];\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\ttagStack.push({ name: matches[j][1], properties });\n\n\t\t\t\t\t\tconst { tagStyle } = this.textStyles.default;\n\t\t\t\t\t\t// if using bbtag style, take styling information in a different way\n\t\t\t\t\t\tif (tagStyle === TAG_STYLE.bbcode && matches[j][0].includes('=') && this.textStyles[matches[j][1]]) {\n\t\t\t\t\t\t\tconst bbcodeRegex = this.getBBcodePropertyRegex();\n\t\t\t\t\t\t\tconst bbcodeTags = bbcodeRegex.exec(matches[j][0]);\n\t\t\t\t\t\t\tlet bbStyle:{ [key: string]: string } = {};\n\t\t\t\t\t\t\tObject.entries(this.textStyles[matches[j][1]]).forEach( style => {\n\t\t\t\t\t\t\t\tbbStyle[style[0]] = typeof style[1] !== 'string'? style[1] : bbcodeTags[1] + style[1];\n\t\t\t\t\t\t\t})\n\t\t\t\t\t\t\tstyleStack.push(this.assign({}, styleStack[styleStack.length - 1], bbStyle));\n\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tstyleStack.push(this.assign({}, styleStack[styleStack.length - 1], this.textStyles[matches[j][1]]));\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\n\t\t\t\t\t// update the current search index\n\t\t\t\t\tcurrentSearchIdx = matches[j].index + matches[j][0].length;\n\t\t\t\t}\n\n\t\t\t\t// is there any character left?\n\t\t\t\tif (currentSearchIdx < lines[i].length) {\n\t\t\t\t\tconst result = this.createTextData(\n\t\t\t\t\t\tcurrentSearchIdx ? lines[i].substring(currentSearchIdx) : lines[i],\n\t\t\t\t\t\tstyleStack[styleStack.length - 1],\n\t\t\t\t\t\ttagStack[tagStack.length - 1]\n\t\t\t\t\t)\n\t\t\t\t\tlineTextData.push(result);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\toutputTextData.push(lineTextData);\n\t\t}\n\n\t\t// don't display any incomplete tags at the end of text- good for scrolling text in games\n\t\tconst { tagStyle } = this.textStyles.default;\n\t\toutputTextData[outputTextData.length-1].map( data => {\n\t\t\tif (data.text.includes(TAG[tagStyle][0])) data.text = data.text.match(tagStyle === TAG_STYLE.bbcode ? /^(.*)\\[/ : /^(.*)\\</)[1]\n\t\t});\n\n\t\treturn outputTextData;\n\t}\n\n\tprivate getFontString(style: TextStyleExtended): string {\n\t\treturn new PIXI.TextStyle(style).toFontString();\n\t}\n\n\tprivate createTextData(text: string, style: TextStyleExtended, tag: TagData): TextData {\n\t\treturn {\n\t\t\ttext,\n\t\t\tstyle,\n\t\t\twidth: 0,\n\t\t\theight: 0,\n\t\t\tfontProperties: undefined,\n\t\t\ttag\n\t\t};\n\t}\n\n\tprivate getDropShadowPadding(): number {\n\t\tlet maxDistance = 0;\n\t\tlet maxBlur = 0;\n\n\t\t Object.keys(this.textStyles).forEach((styleKey) => {\n\t\t\tlet { dropShadowDistance, dropShadowBlur } = this.textStyles[styleKey];\n\t\t\tmaxDistance = Math.max(maxDistance, dropShadowDistance || 0);\n\t\t\tmaxBlur = Math.max(maxBlur, dropShadowBlur || 0);\n\t\t});\n\n\t\treturn maxDistance + maxBlur;\n\t}\n\n  private withPrivateMembers(): TextWithPrivateMembers {\n    return ((this as unknown) as TextWithPrivateMembers);\n  }\n\n  public updateText(): void {\n\t\tif (!this.withPrivateMembers().dirty) {\n\t\t\treturn;\n\t\t}\n\n\t\tthis.hitboxes = [];\n\n\t\tthis.texture.baseTexture.resolution = this.resolution;\n\t\tlet textStyles = this.textStyles;\n\t\tlet outputText = this.text;\n\n\t\tif(this.withPrivateMembers()._style.wordWrap) {\n\t\t\toutputText = this.wordWrap(this.text);\n\t\t}\n\n\t\t// split text into lines\n\t\tlet lines = outputText.split(/(?:\\r\\n|\\r|\\n)/);\n\n\t\t// get the text data with specific styles\n\t\tlet outputTextData = this._getTextDataPerLine(lines);\n\n\t\t// calculate text width and height\n\t\tlet lineWidths: number[] = [];\n\t\tlet lineYMins: number[] = [];\n\t\tlet lineYMaxs: number[] = [];\n\t\tlet baselines: number[] = [];\n\t\tlet maxLineWidth = 0;\n\n\t\tfor (let i = 0; i < lines.length; i++) {\n\t\t\tlet lineWidth = 0;\n\t\t\tlet lineYMin = 0;\n\t\t\tlet lineYMax = 0;\n\t\t\tlet baseline = 0;\n\t\t\tfor (let j = 0; j < outputTextData[i].length; j++) {\n\t\t\t\tlet sty = outputTextData[i][j].style;\n\n\t\t\t\tthis.context.font = this.getFontString(sty);\n\n\t\t\t\t// save the width\n\t\t\t\toutputTextData[i][j].width = this.context.measureText(outputTextData[i][j].text).width;\n\n\t\t\t\tif (outputTextData[i][j].text.length !== 0) {\n\t\t\t\t\toutputTextData[i][j].width += (outputTextData[i][j].text.length - 1) * sty.letterSpacing;\n\n\t\t\t\t\tif (j > 0) {\n\t\t\t\t\t\tlineWidth += sty.letterSpacing / 2; // spacing before first character\n\t\t\t\t\t}\n\n\t\t\t\t\tif (j < outputTextData[i].length - 1) {\n\t\t\t\t\t\tlineWidth += sty.letterSpacing / 2; // spacing after last character\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tlineWidth += outputTextData[i][j].width;\n\n\t\t\t\t// save the font properties\n\t\t\t\toutputTextData[i][j].fontProperties = PIXI.TextMetrics.measureFont(this.context.font);\n\n\t\t\t\t// save the height\n\t\t\t\toutputTextData[i][j].height = outputTextData[i][j].fontProperties.fontSize;\n\n\t\t\t\tif (typeof sty.valign === \"number\") {\n\t\t\t\t\tlineYMin =\n\t\t\t\t\t\tMath.min(\n\t\t\t\t\t\t\tlineYMin,\n\t\t\t\t\t\t\tsty.valign\n\t\t\t\t\t\t\t\t- outputTextData[i][j].fontProperties.descent);\n\t\t\t\t\tlineYMax =\n\t\t\t\t\t\tMath.max(\n\t\t\t\t\t\t\tlineYMax,\n\t\t\t\t\t\t\tsty.valign\n\t\t\t\t\t\t\t\t+ outputTextData[i][j].fontProperties.ascent);\n\t\t\t\t} else {\n\t\t\t\t\tlineYMin =\n\t\t\t\t\t\tMath.min(\n\t\t\t\t\t\t\tlineYMin,\n\t\t\t\t\t\t\t-outputTextData[i][j].fontProperties.descent);\n\t\t\t\t\tlineYMax =\n\t\t\t\t\t\tMath.max(\n\t\t\t\t\t\t\tlineYMax,\n\t\t\t\t\t\t\toutputTextData[i][j].fontProperties.ascent);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tlineWidths[i] = lineWidth;\n\t\t\tlineYMins[i] = lineYMin;\n\t\t\tlineYMaxs[i] = lineYMax;\n\t\t\tmaxLineWidth = Math.max(maxLineWidth, lineWidth);\n\t\t}\n\n\t\t// transform styles in array\n\t\tlet stylesArray = Object.keys(textStyles).map((key) => textStyles[key]);\n\n\t\tlet maxStrokeThickness = stylesArray.reduce((prev, cur) => Math.max(prev, cur.strokeThickness || 0), 0);\n\n\t\tlet dropShadowPadding = this.getDropShadowPadding();\n\n\t\tlet totalHeight = lineYMaxs.reduce((prev, cur) => prev + cur, 0) - lineYMins.reduce((prev, cur) => prev + cur, 0);\n\n\t\t// define the right width and height\n\t\tlet width = maxLineWidth + 2 * maxStrokeThickness + 2 * dropShadowPadding;\n\t\tlet height = totalHeight + 2 * maxStrokeThickness + 2 * dropShadowPadding;\n\n\t\tthis.canvas.width = width * this.resolution;\n\t\tthis.canvas.height = height * this.resolution;\n\n\t\tthis.context.scale(this.resolution, this.resolution);\n\n\t\tthis.context.textBaseline = \"alphabetic\";\n\t\tthis.context.lineJoin = \"round\";\n\n\t\tlet basePositionY = dropShadowPadding + maxStrokeThickness;\n\n\t\tlet drawingData: TextDrawingData[] = [];\n\n\t\t// Compute the drawing data\n\t\tfor (let i = 0; i < outputTextData.length; i++) {\n\t\t\tlet line = outputTextData[i];\n\t\t\tlet linePositionX: number;\n\n\t\t\tswitch (this.withPrivateMembers()._style.align) {\n\t\t\t\tcase \"left\":\n\t\t\t\t\tlinePositionX = dropShadowPadding + maxStrokeThickness;\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase \"center\":\n\t\t\t\t\tlinePositionX = dropShadowPadding + maxStrokeThickness + (maxLineWidth - lineWidths[i]) / 2;\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase \"right\":\n\t\t\t\t\tlinePositionX = dropShadowPadding + maxStrokeThickness + maxLineWidth - lineWidths[i];\n\t\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\tfor (let j = 0; j < line.length; j++) {\n\t\t\t\tlet { style, text, fontProperties, width, height, tag } = line[j];\n\n\t\t\t\tlet linePositionY = basePositionY + fontProperties.ascent;\n\n\t\t\t\tswitch (style.valign) {\n\t\t\t\t\tcase \"top\":\n\t\t\t\t\t\t// no need to do anything\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tcase \"baseline\":\n\t\t\t\t\t\tlinePositionY += lineYMaxs[i] - fontProperties.ascent;\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tcase \"middle\":\n\t\t\t\t\t\tlinePositionY += (lineYMaxs[i] - lineYMins[i] - fontProperties.ascent - fontProperties.descent) / 2;\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tcase \"bottom\":\n\t\t\t\t\t\tlinePositionY += lineYMaxs[i] - lineYMins[i] - fontProperties.ascent - fontProperties.descent;\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tdefault:\n\t\t\t\t\t\t// A number - offset from baseline, positive is higher\n\t\t\t\t\t\tlinePositionY += lineYMaxs[i] - fontProperties.ascent - style.valign;\n\t\t\t\t\t\tbreak;\n\t\t\t\t}\n\n\t\t\t\tif (style.letterSpacing === 0) {\n\t\t\t\t\tdrawingData.push({\n\t\t\t\t\t\ttext,\n\t\t\t\t\t\tstyle,\n\t\t\t\t\t\tx: linePositionX,\n\t\t\t\t\t\ty: linePositionY,\n\t\t\t\t\t\twidth,\n\t\t\t\t\t\tascent: fontProperties.ascent,\n\t\t\t\t\t\tdescent: fontProperties.descent,\n\t\t\t\t\t\ttag\n\t\t\t\t\t});\n\n\t\t\t\t\tlinePositionX += line[j].width;\n\t\t\t\t} else {\n\t\t\t\t\tthis.context.font = this.getFontString(line[j].style);\n\n\t\t\t\t\tfor (let k = 0; k < text.length; k++) {\n\t\t\t\t\t\tif (k > 0 || j > 0) {\n\t\t\t\t\t\t\tlinePositionX += style.letterSpacing / 2;\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tlet charWidth = this.context.measureText(text.charAt(k)).width;\n\n\t\t\t\t\t\tdrawingData.push({\n\t\t\t\t\t\t\ttext: text.charAt(k),\n\t\t\t\t\t\t\tstyle,\n\t\t\t\t\t\t\tx: linePositionX,\n\t\t\t\t\t\t\ty: linePositionY,\n\t\t\t\t\t\t\twidth: charWidth,\n\t\t\t\t\t\t\tascent: fontProperties.ascent,\n\t\t\t\t\t\t\tdescent: fontProperties.descent,\n\t\t\t\t\t\t\ttag\n\t\t\t\t\t\t});\n\n\t\t\t\t\t\tlinePositionX += charWidth;\n\n\t\t\t\t\t\tif (k < text.length - 1 || j < line.length - 1) {\n\t\t\t\t\t\t\tlinePositionX += style.letterSpacing / 2;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tbasePositionY += lineYMaxs[i] - lineYMins[i];\n\t\t}\n\n\t\tthis.context.save();\n\n\t\t// First pass: draw the shadows only\n\t\tdrawingData.forEach(({ style, text, x, y }) => {\n\t\t\tif (!style.dropShadow) {\n\t\t\t\treturn; // This text doesn't have a shadow\n\t\t\t}\n\n\t\t\tthis.context.font = this.getFontString(style);\n\n\t\t\tlet dropFillStyle = style.dropShadowColor;\n\t\t\tif (typeof dropFillStyle === \"number\") {\n\t\t\t\tdropFillStyle = PIXI.utils.hex2string(dropFillStyle);\n\t\t\t}\n\t\t\tthis.context.shadowColor = dropFillStyle;\n\t\t\tthis.context.shadowBlur = style.dropShadowBlur;\n\t\t\tthis.context.shadowOffsetX = Math.cos(style.dropShadowAngle) * style.dropShadowDistance * this.resolution;\n\t\t\tthis.context.shadowOffsetY = Math.sin(style.dropShadowAngle) * style.dropShadowDistance * this.resolution;\n\n\t\t\tthis.context.fillText(text, x, y);\n\t\t});\n\n\t\tthis.context.restore();\n\n\t\t// Second pass: draw the strokes only\n\t\tdrawingData.forEach(({ style, text, x, y, width, ascent, descent, tag }) => {\n\t\t\tif (style.stroke === undefined || !style.strokeThickness) {\n\t\t\t\treturn; // Skip this step if we have no stroke\n\t\t\t}\n\n\t\t\tthis.context.font = this.getFontString(style);\n\n\t\t\tlet strokeStyle = style.stroke;\n\t\t\tif (typeof strokeStyle === \"number\") {\n\t\t\t\tstrokeStyle = PIXI.utils.hex2string(strokeStyle);\n\t\t\t}\n\n\t\t\tthis.context.strokeStyle = strokeStyle;\n\t\t\tthis.context.lineWidth = style.strokeThickness;\n\n\t\t\tthis.context.strokeText(text, x, y);\n\t\t});\n\n\t\t// Third pass: draw the fills only\n\t\tdrawingData.forEach(({ style, text, x, y, width, ascent, descent, tag }) => {\n\t\t\tif (style.fill === undefined) {\n\t\t\t\treturn; // Skip this step if we have no fill\n\t\t\t}\n\n\t\t\tthis.context.font = this.getFontString(style);\n\n\t\t\t// set canvas text styles\n\t\t\tlet fillStyle = style.fill;\n\t\t\tif (typeof fillStyle === \"number\") {\n\t\t\t\tfillStyle = PIXI.utils.hex2string(fillStyle);\n\t\t\t} else if (Array.isArray(fillStyle)) {\n\t\t\t\tfor (let i = 0; i < fillStyle.length; i++) {\n\t\t\t\t\tlet fill = fillStyle[i];\n\t\t\t\t\tif (typeof fill === \"number\") {\n\t\t\t\t\t\tfillStyle[i] = PIXI.utils.hex2string(fill);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tthis.context.fillStyle = ((this as unknown) as TextWithPrivateMembers)._generateFillStyle(new PIXI.TextStyle(style), [text]) as string | CanvasGradient;\n\t\t\t// Typecast required for proper typechecking\n\n\t\t\tthis.context.fillText(text, x, y);\n\t\t});\n\n\t\t// Fourth pass: collect the bounding boxes and draw the debug information\n\t\tdrawingData.forEach(({ style, text, x, y, width, ascent, descent, tag }) => {\n\t\t\tlet offset = -this.withPrivateMembers()._style.padding - this.getDropShadowPadding();\n\n\t\t\tthis.hitboxes.push({\n\t\t\t\ttag,\n\t\t\t\thitbox: new PIXI.Rectangle(x + offset, y - ascent + offset, width, ascent + descent)\n\t\t\t});\n\n\t\t\tlet debugSpan = style.debug === undefined\n\t\t\t\t? MultiStyleText.debugOptions.spans.enabled\n\t\t\t\t: style.debug;\n\n\t\t\tif (debugSpan) {\n\t\t\t\tthis.context.lineWidth = 1;\n\n\t\t\t\tif (MultiStyleText.debugOptions.spans.bounding) {\n\t\t\t\t\tthis.context.fillStyle = MultiStyleText.debugOptions.spans.bounding;\n\t\t\t\t\tthis.context.strokeStyle = MultiStyleText.debugOptions.spans.bounding;\n\t\t\t\t\tthis.context.beginPath();\n\t\t\t\t\tthis.context.rect(x, y - ascent, width, ascent + descent);\n\t\t\t\t\tthis.context.fill();\n\t\t\t\t\tthis.context.stroke();\n\t\t\t\t\tthis.context.stroke(); // yes, twice\n\t\t\t\t}\n\n\t\t\t\tif (MultiStyleText.debugOptions.spans.baseline) {\n\t\t\t\t\tthis.context.strokeStyle = MultiStyleText.debugOptions.spans.baseline;\n\t\t\t\t\tthis.context.beginPath();\n\t\t\t\t\tthis.context.moveTo(x, y);\n\t\t\t\t\tthis.context.lineTo(x + width, y);\n\t\t\t\t\tthis.context.closePath();\n\t\t\t\t\tthis.context.stroke();\n\t\t\t\t}\n\n\t\t\t\tif (MultiStyleText.debugOptions.spans.top) {\n\t\t\t\t\tthis.context.strokeStyle = MultiStyleText.debugOptions.spans.top;\n\t\t\t\t\tthis.context.beginPath();\n\t\t\t\t\tthis.context.moveTo(x, y - ascent);\n\t\t\t\t\tthis.context.lineTo(x + width, y - ascent);\n\t\t\t\t\tthis.context.closePath();\n\t\t\t\t\tthis.context.stroke();\n\t\t\t\t}\n\n\t\t\t\tif (MultiStyleText.debugOptions.spans.bottom) {\n\t\t\t\t\tthis.context.strokeStyle = MultiStyleText.debugOptions.spans.bottom;\n\t\t\t\t\tthis.context.beginPath();\n\t\t\t\t\tthis.context.moveTo(x, y + descent);\n\t\t\t\t\tthis.context.lineTo(x + width, y + descent);\n\t\t\t\t\tthis.context.closePath();\n\t\t\t\t\tthis.context.stroke();\n\t\t\t\t}\n\n\t\t\t\tif (MultiStyleText.debugOptions.spans.text) {\n\t\t\t\t\tthis.context.fillStyle = \"#ffffff\";\n\t\t\t\t\tthis.context.strokeStyle = \"#000000\";\n\t\t\t\t\tthis.context.lineWidth = 2;\n\t\t\t\t\tthis.context.font = \"8px monospace\";\n\t\t\t\t\tthis.context.strokeText(tag.name, x, y - ascent + 8);\n\t\t\t\t\tthis.context.fillText(tag.name, x, y - ascent + 8);\n\t\t\t\t\tthis.context.strokeText(`${width.toFixed(2)}x${(ascent + descent).toFixed(2)}`, x, y - ascent + 16);\n\t\t\t\t\tthis.context.fillText(`${width.toFixed(2)}x${(ascent + descent).toFixed(2)}`, x, y - ascent + 16);\n\t\t\t\t}\n\t\t\t}\n\t\t});\n\n\t\tif (MultiStyleText.debugOptions.objects.enabled) {\n\t\t\tif (MultiStyleText.debugOptions.objects.bounding) {\n\t\t\t\tthis.context.fillStyle = MultiStyleText.debugOptions.objects.bounding;\n\t\t\t\tthis.context.beginPath();\n\t\t\t\tthis.context.rect(0, 0, width, height);\n\t\t\t\tthis.context.fill();\n\t\t\t}\n\n\t\t\tif (MultiStyleText.debugOptions.objects.text) {\n\t\t\t\tthis.context.fillStyle = \"#ffffff\";\n\t\t\t\tthis.context.strokeStyle = \"#000000\";\n\t\t\t\tthis.context.lineWidth = 2;\n\t\t\t\tthis.context.font = \"8px monospace\";\n\t\t\t\tthis.context.strokeText(`${width.toFixed(2)}x${height.toFixed(2)}`, 0, 8, width);\n\t\t\t\tthis.context.fillText(`${width.toFixed(2)}x${height.toFixed(2)}`, 0, 8, width);\n\t\t\t}\n\t\t}\n\n\t\tthis.updateTexture();\n\t}\n\n\tprotected wordWrap(text: string): string {\n\t\t// Greedy wrapping algorithm that will wrap words as the line grows longer than its horizontal bounds.\n\t\tlet result = \"\";\n\t\tlet re = this.getTagRegex(true, true);\n\n\t\tconst lines = text.split(\"\\n\");\n\t\tconst wordWrapWidth = this.withPrivateMembers()._style.wordWrapWidth;\n\t\tlet styleStack = [this.assign({}, this.textStyles[\"default\"])];\n\t\tthis.context.font = this.getFontString(this.textStyles[\"default\"]);\n\n\t\tfor (let i = 0; i < lines.length; i++) {\n\t\t\tlet spaceLeft = wordWrapWidth;\n\t\t\tconst tagSplit = lines[i].split(re);\n\t\t\tlet firstWordOfLine = true;\n\n\t\t\tfor (let j = 0; j < tagSplit.length; j++) {\n\t\t\t\tif (re.test(tagSplit[j])) {\n\t\t\t\t\tresult += tagSplit[j];\n\t\t\t\t\tif (tagSplit[j][1] === \"/\") {\n\t\t\t\t\t\tj += 2;\n\t\t\t\t\t\tstyleStack.pop();\n\t\t\t\t\t} else {\n\t\t\t\t\t\tj++;\n\t\t\t\t\t\tstyleStack.push(this.assign({}, styleStack[styleStack.length - 1], this.textStyles[tagSplit[j]]));\n\t\t\t\t\t\tj++;\n\t\t\t\t\t}\n\t\t\t\t\tthis.context.font = this.getFontString(styleStack[styleStack.length - 1]);\n\t\t\t\t} else {\n\t\t\t\t\tconst words = tagSplit[j].split(\" \");\n\n\t\t\t\t\tfor (let k = 0; k < words.length; k++) {\n\t\t\t\t\t\tconst wordWidth = this.context.measureText(words[k]).width;\n\n\t\t\t\t\t\tif (this.withPrivateMembers()._style.breakWords && wordWidth > spaceLeft) {\n\t\t\t\t\t\t\t// Part should be split in the middle\n\t\t\t\t\t\t\tconst characters = words[k].split('');\n\n\t\t\t\t\t\t\tif (k > 0) {\n\t\t\t\t\t\t\t\tresult += \" \";\n\t\t\t\t\t\t\t\tspaceLeft -= this.context.measureText(\" \").width;\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\tfor (let c = 0; c < characters.length; c++) {\n\t\t\t\t\t\t\t\tconst characterWidth = this.context.measureText(characters[c]).width;\n\n\t\t\t\t\t\t\t\tif (characterWidth > spaceLeft) {\n\t\t\t\t\t\t\t\t\tresult += `\\n${characters[c]}`;\n\t\t\t\t\t\t\t\t\tspaceLeft = wordWrapWidth - characterWidth;\n\t\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\t\tresult += characters[c];\n\t\t\t\t\t\t\t\t\tspaceLeft -= characterWidth;\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t} else if(this.withPrivateMembers()._style.breakWords) {\n\t\t\t\t\t\t\tresult += words[k];\n\t\t\t\t\t\t\tspaceLeft -= wordWidth;\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tconst paddedWordWidth =\n\t\t\t\t\t\t\t\twordWidth + (k > 0 ? this.context.measureText(\" \").width : 0);\n\n\t\t\t\t\t\t\tif (paddedWordWidth > spaceLeft) {\n\t\t\t\t\t\t\t\t// Skip printing the newline if it's the first word of the line that is\n\t\t\t\t\t\t\t\t// greater than the word wrap width.\n\t\t\t\t\t\t\t\tif (!firstWordOfLine) {\n\t\t\t\t\t\t\t\t\tresult += \"\\n\";\n\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t\tresult += words[k];\n\t\t\t\t\t\t\t\tspaceLeft = wordWrapWidth - wordWidth;\n\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\tspaceLeft -= paddedWordWidth;\n\n\t\t\t\t\t\t\t\tif (k > 0) {\n\t\t\t\t\t\t\t\t\tresult += \" \";\n\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t\tresult += words[k];\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\tfirstWordOfLine = false;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif (i < lines.length - 1) {\n\t\t\t\tresult += '\\n';\n\t\t\t}\n\t\t}\n\n\t\treturn result;\n\t}\n\n\tprotected updateTexture() {\n\t\tconst texture = this.withPrivateMembers()._texture;\n\n\t\tlet dropShadowPadding = this.getDropShadowPadding();\n\n    texture.baseTexture.setRealSize(this.canvas.width, this.canvas.height, this.resolution);\n\t\ttexture.trim.width = texture.frame.width = this.canvas.width / this.resolution;\n\t\ttexture.trim.height = texture.frame.height = this.canvas.height / this.resolution;\n\n\t\ttexture.trim.x = -this.withPrivateMembers()._style.padding - dropShadowPadding;\n\t\ttexture.trim.y = -this.withPrivateMembers()._style.padding - dropShadowPadding;\n\n\t\ttexture.orig.width = texture.frame.width - (this.withPrivateMembers()._style.padding + dropShadowPadding) * 2;\n\t\ttexture.orig.height = texture.frame.height - (this.withPrivateMembers()._style.padding + dropShadowPadding) * 2;\n\n\t\t// call sprite onTextureUpdate to update scale if _width or _height were set\n\t\tthis.withPrivateMembers()._onTextureUpdate();\n\n\t\ttexture.baseTexture.emit('update', texture.baseTexture);\n\n\t\tthis.withPrivateMembers().dirty = false;\n\t}\n\n\t// Lazy fill for Object.assign\n\tprivate assign(destination: any, ...sources: any[]): any {\n\t\tfor (let source of sources) {\n\t\t\tfor (let key in source) {\n\t\t\t\tdestination[key] = source[key];\n\t\t\t}\n\t\t}\n\n\t\treturn destination;\n\t}\n}\n"],"names":["parseInt","PIXI","split","Error","const","INTERACTION_EVENTS","TAG","bbcode","xml","MultiStyleText","constructor","text","styles","forEach","event","on","e","this","handleInteraction","ev","localPoint","data","getLocalPosition","targetTag","hitboxes","reduce","prev","hitbox","undefined","contains","x","y","tag","let","style","textStyles","assign","DEFAULT_TAG_STYLE","default","tagStyle","b","fontStyle","i","color","fill","outline","stroke","strokeThickness","font","fontFamily","shadow","dropShadowColor","dropShadow","dropShadowBlur","dropShadowDistance","dropShadowAngle","size","fontSize","spacing","letterSpacing","align","withPrivateMembers","_style","dirty","setTagStyle","deleteTagStyle","getTagRegex","captureName","captureMatch","tagAlternation","Object","keys","join","reStr","RegExp","getPropertyRegex","getBBcodePropertyRegex","_getTextDataPerLine","lines","outputTextData","re","styleStack","tagStack","name","properties","length","lineTextData","matches","matchArray","exec","push","createTextData","currentSearchIdx","j","index","substring","pop","propertyRegex","propertyMatch","includes","bbcodeTags","bbStyle","entries","result","map","match","getFontString","toFontString","width","height","fontProperties","getDropShadowPadding","maxDistance","maxBlur","styleKey","Math","max","updateText","texture","baseTexture","resolution","outputText","wordWrap","lineWidths","lineYMins","lineYMaxs","maxLineWidth","lineWidth","lineYMin","lineYMax","sty","context","measureText","measureFont","valign","min","descent","ascent","maxStrokeThickness","key","cur","dropShadowPadding","canvas","scale","textBaseline","lineJoin","basePositionY","drawingData","line","linePositionX","linePositionY","k","charWidth","charAt","save","dropFillStyle","hex2string","shadowColor","shadowBlur","shadowOffsetX","cos","shadowOffsetY","sin","fillText","restore","strokeStyle","strokeText","fillStyle","Array","isArray","_generateFillStyle","offset","padding","debug","debugOptions","spans","enabled","bounding","beginPath","rect","baseline","moveTo","lineTo","closePath","top","bottom","toFixed","objects","updateTexture","wordWrapWidth","spaceLeft","tagSplit","firstWordOfLine","test","words","wordWidth","breakWords","characters","c","characterWidth","paddedWordWidth","_texture","setRealSize","trim","frame","orig","_onTextureUpdate","emit","destination","sources","source","PI","fillGradientType","LINEAR_VERTICAL","fontVariant","fontWeight","lineHeight","miterLimit"],"mappings":"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"}